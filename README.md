## 一、设计模式介绍

> 设计模式是在软件设计中常见问题的通用、可反复使用、多数人知晓的一种解决方案或模板，这些解决方案是在相当长的一段时间内由众多软件开发人员通过反复试验获得的。



## 二、设计模式七大原则

### 2.1 单一职责原则

> 每一个类只负责一个职责，例如 Java 中 Math 工具类，只负责和数学相关的方法运算。

* 参考博客
    * [单一职责](https://blog.csdn.net/zhengzhb/article/details/7278174)



### 2.2 接口隔离原则

> 客户端不应该依赖它不需要的接口，类之间的依赖关系应该建立在最小的接口上。例如 Java 中集合类的 List 接口和 Deque 接口，同样是对元素的 CRUD 操作，拆分成两个语义的接口，实现类可以通过实现这些接口构成不同的数据结构。

* 参考博客
    * [接口隔离原则]()



### 2.3 依赖倒转原则

> 高层模块不应该依赖低层模块，二者都应该依赖其抽象；
>
> 抽象不应该依赖细节，细节应该依赖抽象。
>
> 依赖倒转的思想具体来说就是面向接口/抽象类编程。
>
> 例如 Java 中的 JDBC 接口，定义一套统一操作数据库的接口，具体的实现交给各家的数据库厂商。我们使用时并不需要知道它们的实现细节，只需要通过这套接口调用具体的数据库操作即可。即使以后更换数据库，也不用修改代码。

* 参考博客
    * [依赖倒转原则](https://blog.csdn.net/king123456man/article/details/81626127)



### 2.4 里氏替换原则

> **定义1：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型;**
>
> **定义2：所有引用基类的地方必须能透明地使用其子类的对象。**
>
> 核心思想：当使用继承时，要遵循里氏替换原则。类 B 继承类 A 时，除添加新的方法完成新增功能 P2 外，尽量不要重写父类 A 的方法，也尽量不要重载父类 A 的方法。

* 参考博客

    * [里氏替换原则](https://blog.csdn.net/zhengzhb/article/details/7281833)

          



### 2.5 开闭原则

> 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。

* 参考博客
    * [开闭原则](https://blog.csdn.net/zhengzhb/article/details/7296944)





### 2.6 迪米特法则

> 1. 迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public 方法，不对外泄露任何信息
> 2. 迪米特法则还有个更简单的定义：只与 "直接的朋友" 通信。所谓的直接朋友是指：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，**陌生的类最好不要以局部变量的形式出现在类的内部**。

* 参考博客
    * [迪米特法则](https://blog.csdn.net/zhengzhb/article/details/7296930)





### 2.7 合成复用原则

> 尽量使用对象组合，而不是继承来达到复用的目的。组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少。通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性。

* 参考博客
    * [合成复用原则](https://blog.csdn.net/LoveLion/article/details/7563441)







## 三、UML 类图

### 3.1 类图的基本表示

* 成员变量
* 成员方法
* 类的分类



### 3.2 类之间的关系

* 依赖
* 泛化
* 实现
* 关联
* 聚合
* 组合





## 四、设计模式三大分类

### 4.1 创建者模式

##### 4.1.1 单例模式

* 定义

    > 采取一定的方法保证在整个的软件系统中，对某个类**只能存在一个对象实例**， 并且该类**只提供一个取得其对象实例的方法(静态方法)**。

* 实现方式

    * 饿汉式
    * 懒汉式
        * **特别注意枚举和双重检验实现**

* 源码: **`java.lang.runtime`**





##### 4.1.2 <font color="red">工厂方法模式</font>

* 扩展：简单工厂模式

    * java.lang.calendar 类源码

    * 定义

        > 定义一个工厂类，专门负责对象的创建。

* 定义

    > **将工厂类的创建对象的方法定义为抽象方法**，具体的实现交给子类工厂类。
    >
    > 举的案例不太好的，参考其他。





##### 4.1.3 抽象工厂模式

* 定义

    > 提供**一个创建一系列相关或相互依赖的对象的接口**或者抽象类，而无需指定它们具体的类。
    >
    > 工厂方法模式和抽象工厂方法模式的区别是生产产品规模的不同。如果只存在一种类型的产品，选择工厂方法模式，存在多种类型的产品，选用抽象工厂模式。





##### 4.1.4 建造者模式

* 定义

    > **将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。**

* 难点: **注意与抽象工厂模式的区别**

* 源码运用: `java.lang.StringBuilder`



##### 4.1.5 原型模式

* 定义

    > 用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象。

* 针对**原型实例的引用类型**存在两种拷贝实现方式

    * 浅拷贝（使用默认实现的 clone 方法）

    * 深拷贝

        * 实现方式

            1)   重写 **clone** 方法来实现深拷贝

            2)   **通过对象序列化实现深拷贝(推荐)**

* 源码运用: Spring bean 的作用域 Scope 值为 `prototype` 的时候，通过 Debug 追踪源码。 








### 4.2 结构型模式

##### 4.2.1 适配器模式

* 定义

    > 把**一个类(Source)**的接口变换成客户端所期待的**另一种接口(target)**，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作。

* 实现方式

    * 类适配器模式

        适配器 Adapter 类，**通过继承 source 类**，实现 target 类接口，完成 src->dst 的适配。

    * **对象适配器模式**

        适配器 Adapter 类，**通过持有 source 类的实例**，实现 target 类接口，完成 src->dst 的适配。

    * 接口适配器模式

        先设计**一个抽象类实现接口**，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求。

* 源码：**Spring MVC 的 HandlerAdapter**。





##### 4.2.2 桥接模式

* 定义

    > **将抽象部分与它的实现部分分离，使它们都可以独立地变化。**

* 源码: **jdbc 的 Connection 接口**





##### 4.2.3 装饰者模式

* 定义

    > **动态将职责附加到对象上**，若要扩展功能，装饰者提供了比继承更具弹性的代替方案。

* 源码: **JDK 的 InputStream**





##### 4.2.4 组合模式

* 定义

    > 又称为部分整体模式，它创建了**对象组的树形结构**，将对象组合成树状结构以表示“整体**-**部分”的层次关系，使得用户对**单个对象和组合对象的访问具有一致性**。

* 源码: **JDK 的 HashMap**





##### 4.2.5 外观模式

* 定义

    > 通过创建一个统一的类，用来包装子系统中一个或多个复杂的类，客户端可以通过调用外观类的方法来调用内部子系统中所有方法

* 源码: **MyBatis** 中的 **Configuration** 创建 **MetaObject**





##### 4.2.6 享元模式

* 定义

    > 它摒弃了在每个对象中保存所有数据的方式， **通过共享多个对象所共有的相同状态**， 让你能在有限的内存容量中载入更多对象。

* 源码: **JDK 的 Integer**





##### 4.2.7 代理模式

* 定义

    > 为一个对象提供**一个代理**，以控制对这个对象的访问。即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即**扩展目标对象的功能**。

* 实现方式

    * 静态代理
    * 动态代理
    * Cglib 代理

* 总结

    > 静态代理和动态代理都需要目标对象实现的接口，而 Cglib 不需要。静态代理和动态代理的区别就是动态代理的代理对象不需要实现与目标对象一样的接口，但是依然要求目标对象有实现接口才行。









### 4.3 行为型模式

##### 4.3.1 模板方法模式

* 定义

    > 在一个方法中定义**算法的骨架**，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定步骤。

* 源码：**Spring IOC 容器初始化时 AbstractApplicationContext**

* 源码：**JDK 的 Arrays.sort()** 





##### 4.3.2 命令模式

* 定义

    > **将一个请求封装成一个对象**，用不同参数来表示不同的请求(即命名)，同时命令模式也支持可撤销的操作。

* 源码：**Spring 框架的 JDBCTemplate 的 StatementCallback 接口**






##### 4.3.3 迭代器模式

* 定义：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。
* 源码：**java.utils.ArrayList**





##### 4.3.4 观察者模式

* 定义：一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知所有的观察者。

* 源码：**java.util.Observable**





##### 4.3.5 中介者模式

* 定义: 用一个中介对象来封装一系列对象的交互，从而把一批原来可能是交互关系复杂的对象转换成一组松散耦合的中间对象，以有利于维护和修改。

      

    

##### 4.3.6 备忘录模式

* 定义：在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。




##### 4.3.7 解释器模式

* 定义：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
* 源码：**Spring 框架中 SpelExpressionParser**





##### 4.3.8 状态模式

* 定义：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。





##### 4.3.9 策略模式

* 定义：定义一系列的算法，把每一个算法封装起来, 并且使它们可相互替换。使得算法可独立于使用它的客户而变化。
* 源码：**Arrays.sort 的比较因子 Comparator 接口**





##### 4.3.10 职责链模式

* 定义：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。
* 源码：**Spring MVC 的 HandlerExectionChain**





##### 4.3.11 访问者模式

* 定义：将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。







## 五、参考
* [B站尚硅谷韩老师的设计模式](https://www.bilibili.com/video/BV1G4411c7N4?p=1)
* Head First 设计模式
* [国外的设计模式在线教学](https://refactoringguru.cn/design-patterns)

